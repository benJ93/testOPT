library ('nloptr')
vectA <- c(0.0012, 0.0114, 0.044, 0.0162, 0.0021, 0.0419, 0.0417)
vectB <- c(1.4423,0.607,0.7037,1.7106,1.7013,2.2095,1.7013) 
vectC <- c(15.86, 16.098, 3.0391, 6.0502, 5.3922, 8.3339, 8.2559)
	eval_f <- 2
val=rle(vectA)$values
n=0 
for( i in 1:length(val)){ 
 
	eval_f <- function(x){
		return( list( "objective"=vectA[i]*x[i]*x[i]+vectB[i]*x[i]+vectC[i]+eval_f,
				"gradient" = c(2*vectA[i]*x[i]+vectB[i],
						   )))
				   }
				}



# constraint functions
# inequalities
eval_g_ineq <- function( x ) {

for( i in 1:length(val)){
 constr <- c(- x[i] )
				}
constr <- (50 - constr)
 return( list( "constraints"=constr, "jacobian"=grad ) )
 }

grad <-  c( -1,
 -1,
 -1,
 -1 ,
 -1,
 -1,
 -1)

# equalities
eval_g_eq <- function( x ) {
constr <- c( x[1]+x[2]+x[3]+x[4]+x[5]+x[6]+x[7]-1350)
 
grad <- c( 1 ,
      1 ,
      1 ,
      1 ,
      1 ,
      1 ,
      1 )
return( list( "constraints"=constr, "jacobian"=grad ) )
 }
# initial values
 x0 <- c( 210, 210, 210, 70, 70, 50, 50 )
 
# lower and upper bounds of control
 lb <- c( 210, 210, 210, 70, 70, 50, 50 )
 ub <- c( 420, 420, 420, 140, 140, 120, 120 )
 
local_opts <- list( "algorithm" = "NLOPT_LD_MMA",
"xtol_rel" = 1.0e-7 )
opts <- list( "algorithm" = "NLOPT_LD_AUGLAG",
"xtol_rel" =1.0e-7 ,
"maxeval" =1570,
"local_opts" = local_opts )
 
res <- nloptr( x0=x0,
eval_f=eval_f,lb=lb,
ub=ub,
eval_g_ineq=eval_g_ineq,
eval_g_eq=eval_g_eq,
opts=opts)
print( res )